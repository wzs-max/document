

# 									数据结构

## 一、为什么要学习数据结构

### 1.数据结构是高级计算机程序设计的理论指导

我塞牙了，那么就要用到“牙签”这个数据结构，当然你也可以用指甲，但是“性能”没有牙签好；

我要拧螺母，那么就要用到“扳手”这个数据结构，当然用钳子也行，但是“性能”没有扳手好；

**总结：学习数据结构，就是为了了解以后在IT行业里搬砖需要用到什么工具，这些工具有什么利弊，应用于什么场景。**
**你会发现这些基础的“工具”也存在着一些缺陷，你不满足于此工具，此时，你就开始自己在这些数据结构的基础上**
**加以改造，**
**这就叫做自定义数据结构**
**掌握了开车的本领，桑塔纳、宝马、奔驰、老年代步车都会开。数据结构可以采用不同的语言来描述和实现，此处自然是Java语言**

### 2.提升个人编程能力

### 3.面试中经常问到

## 二、有哪些数据结构

**线性表**、栈、队列、（字符）串、数组、广义表、树、**二叉树**、图



## 三、数据结构与算法入门

### 1基本概念

1）数据

数据( data ）是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。

数据的含义非常广泛，除了通常的数值数据、字符、字符串是数据以外，声音、图像等一切可以输入计算机并能被处理的都是数据。例如除了表示人的姓名、身高、体重等的字符、数字是数据，人的照片、指纹、三维模型、语音指令等也都是数据。

2）数据项：

数据项( data item)具有原子性，是不可分割的最小数据单位。如描述学生相关信息的姓名、性别、学号等都是数据项;

三维坐标中的每一维坐标值也是数据项。数据项具有原子性，是不可分割的最小单位。

3）数据元素：

数据元素( data element )是数据的基本单位，是数据集合的个体，通常由若干个数据项组成，在计算机程序中通常作为一个整体来进行处理。例如一条描述一位学生的完整信息的数据记录就是一个数据元素﹔空间中一点的三维坐标也可以是一个数据元素。

4）数据对象

数据对象( data object )是性质相同的数据元素的集合，是数据的子集。



![image-20220904090621987](D:\学习\数据结构\image-20220904090621987.png)

5）数据结构

数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。是组织并存储数据以便能够有效的使用的一种专门格式，数据结构用来反映一个数据的内部构成，即一个数据由哪些成分数据构成，以什么方式构成，呈现什么结构。

6）数据结构的表现形式

由于信息可以存在于逻辑思维领域，也可以存在于计算机世界，因此作为信息载体的数据同样存在于两个世界中。表示一组数据元素及其相互关系的数据结构同样也有两种不同的表现形式，**—种是数据结构的逻辑层面，即数据的逻辑结构;一种是存在于计算机世界的物理层面，即数据的存储结构。**

**数据结构 = 逻辑结构 + 存储结构 + 在存储结构上的运算/操作**

![image-20220904091255631](D:\学习\数据结构\image-20220904091255631.png)

###   2.数据结构类型

### 1）逻辑上分类

#### 1）分类一：线性结构和非线性结构

**线性结构**∶有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。线性表就是一个典型的线性结构，它有四个基本特征∶

1.集合中必存在唯一的一个"第一个元素";

2.集合中必存在唯一的一个"最后的元素";

3 .除最后元素之外，其它数据元素均有唯一的"后继";

4.除第一元素之外，其它数据元素均有唯一的"前驱"。

![image-20220904091956606](D:\学习\数据结构\image-20220904091956606.png)

**非线性结构**:一个结点元素可能对应多个直接前驱和多个直接后继。常见的非线性结构有:树(二叉树等)，图(网等)。

![image-20220904092109320](D:\学习\数据结构\image-20220904092109320.png)

#### 2)分类二：集合结构，线性结构，树状结构，网络结构

**逻辑结构有四种基本类型∶集合结构、线性结构、树状结构和网络结构。**
**表和树是最常用的两种高效数据结构，许多高效的算法能够用这两种数据结构来设计实现。**
1.集合结构∶就是数学中所学习的集合。集合中的元素有三个特征:
	1).确定性（集合中的元素必须是确定的)
	2).唯一性(集合中的元素互不相同。例如∶集合A=1，a}，则a不能等于1
	3).无序性（集合中的元素没有先后之分），如集合{3,4,5}和{3,5,4}算作同一个集合该结构的数据元素间的关系是“属于同一个集合”，别无其它关系。
因为集合中元素关系很弱，数据结构中不对该结构进行研究。

2.线性结构∶数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。

3.树状结构∶除了一个数据元素（元素01 )以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素。特点是数据元素之间是1对多的联系。

4.网络结构∶每个数据元素可以有多个直接前驱元素，也可以有多个直接后续元素。特点是数据元素之间是多对多的联系。

![image-20220904093145483](D:\学习\数据结构\image-20220904093145483.png)

### 2）存储上分类

数据的存储结构主要包括数据元素本身的存储以及数据元素之间关系表示，是数据的逻辑结构在计算机中的表示。常见的存储结构有顺序存储，链式存储，索引存储，以及散列存储。

#### 1）顺序存储结构∶

**把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现**。由此得到的存储结构为顺序存储结构，**通常顺序存储结构是借助于计算机程序设计语言（例如C/C++)的数组来描述的**。

【**数据元素的存储对应于一块连续的存储空间，数据元素之间的前驱和后续关系通过数据元素在存储器中的相对位置来反映**】

![image-20220904093743758](D:\学习\数据结构\image-20220904093743758.png)

优点:是节省存储空间，因为分配给数据的存储单元全用存放结点的数据(不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号。由该序号可以直接计算出来结点的存储地址。

缺点:插入和删除操作需要移动元素，效率较低。

#### 2）链式存储结构∶

**数据元素的存储对应的是不连续的存储空间，每个存储节点对应一个需要存储的数据元素**。

每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映出来。

特点:

1、比顺序存储结构的存储密度小(每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多)。

2、**逻辑上**相邻的节点**物理上**不必相邻。

3、插入、删除灵活(不必移动节点，只要改变节点中的指针)。

4、查找结点时链式存储要比顺序存储慢。

![image-20220904094113138](D:\学习\数据结构\image-20220904094113138.png)

#### 3）索引存储结构︰

除建立存储结点信息外，还建立附加的索引表来标识结点的地址。比如图书、字典的目录。

![image-20220904094337722](D:\学习\数据结构\image-20220904094337722.png)



#### 4）散列存储结构︰

根据结点的关键字直接计算出该结点的存储地址—种神奇的结构，添加、查询速度快。

![image-20220904094520350](D:\学习\数据结构\image-20220904094520350.png)

数组+链表



#### 总结：

为什么说存储结构不唯一？

因为一种逻辑结构可以对应多种存储结构，例如线性结构的存储结构有数据和链表都可以表示

![image-20220904094710357](D:\学习\数据结构\image-20220904094710357.png)

### 3.算法

#### 1）什么是算法：

**算法是指令的集合，是为解决特定问题而规定的一系列操作。**
它是明确定义的可计算过程，以一个数据集合作为输入，并产生一个数据集合作为输出。

—个算法通常来说具有以下五个特性:
1)输入:一个算法应以待解决的问题的信息作为输入。

2)输出:输入对应指令集处理后得到的信息。
3)可行性︰算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时间内完成。
4)有穷性:算法执行的指令个数是有限的，每个指令又是在有限时间内完成的，因此整个算法也是在有限时间内可以结束的。
5)确定性:算法对于特定的合法输入，其对应的输出是唯一的。即当算法从一个特定输入开始，多次执行同一指令集结果总是相同的。

**简单的说，算法就是计算机解题的过程。**
在这个过程中，无论是形成解题思路还是编写程序，都是在实施某种算法。前者是算法的逻辑形式，后者是算法的代码形式。

举例:如何求1+2+3+...100=?
算法1∶依次相加
算法2∶高斯解法︰首尾相加*50
算法3∶使用递归实现: sum(100) = sum(99)+100 sum(99)= sum(98)+99
sum(2) = sum(1)+2 sum(1)= 1



#### 2）评价算法优劣的依据∶复杂度（时间复杂度和空间复杂度)

1）算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间资源，因此复杂度分为时间和空间复杂度。

2）时间复杂度是指执行算法所需要的计算工作量。

3）空间复杂度是指执行这个算法所需要的内存空间。

### 4.算法的时间复杂度

**时间复杂度(Time Complexity))定义**

#### 1）时间频度︰

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试
而算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度，表示为T (n )，n表示问题的规模**

#### 2）时间复杂度

但有时我们想知道它变化时呈现什么规律，想知道问题的规模，而不是具体的次数，此时引入时间复杂度。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)使得当n超近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称**O(f(n)为算法的渐进时间复杂度，简称时间复杂度**。
**T(n)=o(f(n))，或者说∶时间复杂度就是时间频度去掉低阶项和首项常数。**
**注意∶时间频度与时间复杂度是不同的，时间频度不同但时间复杂度可能相同。**

比如∶某两个算法的时间频度是T(n) = 100000n2+10n+6 Tn)= n2但是时间复杂度都是T(n) = o(n2)

#### 3）最坏时间复杂度和平均时间复杂度

**最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。**
这样做的原因是∶

最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。在最坏情况下的时间复杂度为T(n)=O(n)，它表示对于任何输入实例,该算法的运行时间不可能大于O(n)。

平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。鉴于平均复杂度第一难计算
第二，有很多算法的平均情况和最差情况的复杂度是一样的。所以一般讨论最坏时问复杂度。

比如我要求你在字典里查同一个字，告诉我这个字在字典的那一页。如果一页一页的翻，你需要多少时间呢?
最优的情况就是这个字在第一页，
最坏的情况就是这个字是整本字典的最后一个字。
所以即使我故意为难你，你也不会花费比找整本字典最后一个字还长的时间。当然，此时聪明的你就会想用部首、笔画等去查，才不要傻乎乎的一页一页翻，此时的你就会择优选择，因为此时你最坏得情况就是我给你部首笔画最多、除部首外笔画最多的一个超级复杂的一个字，但显然比翻整本字典快得多。

![image-20220904101035650](D:\学习\数据结构\image-20220904101035650.png)



#### 4）时间复杂度计算

根本没有必要计算时间频度，即使计算处理还要忽略常量、低次幂和最高次幂的系数，所以可以采用如下简单方法∶

(1)找出算法中的基本语句、算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

(2)计算基本语句的执行次数的数量级;只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上:增长率。

(3)用大O记号表示算法的时间性能。将基本语苟执行次数的数量级放入大O记号中。

#### 5)时间复杂度举例

![image-20220904101515124](D:\学习\数据结构\image-20220904101515124.png)



![image-20220904103355698](D:\学习\数据结构\image-20220904103355698.png)





![image-20220904103652770](D:\学习\数据结构\image-20220904103652770.png)

### 5.算法的空间复杂度

空间复杂度( Space Complexity))
算法的存储量包括:
1.程序本身所占空间

2.输入数据所占空间;

3.辅助变量所占空间
输入数据所占空间只取决于问题本身，和算法无关，则只要分析除输入和程序之外的辅助变量所占额外空问。
空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度，一般也作为问题规模n的函数，以数量级形式给出，记作:s(n) = O(g(n))



![image-20220904104345019](D:\学习\数据结构\image-20220904104345019.png)

![image-20220904104636297](D:\学习\数据结构\image-20220904104636297.png)

**注意**:
1.空间复杂度相比时间复杂度分析要少
2对于递归算法来说，代码一般都比较简短，算法本身所占用的存储空间较少，但运行时需要占用较多的临时工作单元;
若写成非递归算法，代码一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。



## 四、线性表

### 1.线性表及其结构

线性表( linear list ) )

**线性表是n个类型相同性质数据元素的有限序列**，通常记作( a<sub>0</sub> , a <sub>1</sub> , ...a <sub>j-1</sub> , a<sub>i</sub>, a
...,a<sub>n-1</sub> )。

#### 1）相同数据类型

在线性表的定义中，我们看到从a<sub>0</sub>到a <sub>n1</sub>的n个数据元素是具有相同属性的元素。比如说可以都是数字，例如(23,14,66,5,99) ;
也可以是字符，例如(A,B.C,... Z);
当然也可以是具有更复杂结构的数据元素，例如学生、商品、装备。
相同数据类型意味着在内存中存储时，每个元素会占用相同的内存空间，便于后续的查询定位。

#### 2）序列(顺序性)

在线性表的相邻数据元素之间存在着序偶关系，即a<sub>i-1</sub>是a<sub>i</sub>的直接前驱，则a<sub>i</sub>是a <sub>i-1</sub>的直接后续，同时a<sub>i</sub>又是a <sub>i+1</sub>的直接前驱，a<sub>i+1</sub>是a<sub>i</sub>的直接后续。唯—没有直接前驱的元素a<sub>0</sub>一端称为表头，
唯—没有后续的元素a<sub>n-1</sub>一端称为表尾。
除了表头和表尾元素外，任何一个元素都有且仅有一个直接前驱和直接后继

#### 3）有限

线性表中数据元素的个数n定义为线性表的长度，n是一个有限值。当n=0时线性表为空表。
在非空的线性表中每个数据元素在线性表中都有唯一确定的序号，
例如a <sub>0</sub>的序号是0，a<sub>i</sub>的序号是i。
在—个具有n>0个数据元素的线性表中，数据元素序号的范围是[0,n-1]。



![image-20220904141921188](D:\学习\数据结构\image-20220904141921188.png)

### 2.线性表的存储结构

![image-20220904142219727](D:\学习\数据结构\image-20220904142219727.png)



![image-20220904143626668](D:\学习\数据结构\image-20220904143626668.png)





​																						**线性表：顺序表实现**

```java
public interface List {
    public int size();
    public Object get(int i);
    public boolean isEmpty();
    public boolean contains(Object e);
    public int indexOf(Object e);
    public void add(int i,Object e);
    public void add(Object e);
    public void addBefore(Object e,Object e1);
    public void addAfter(Object e,Object e1);
}

```

```java
/**
 * 顺序表:底层采用数组结构，但长度可以动态变化
 */
public class ArrayList implements List{

    private Object[] elementData;//底层是一个数组，当前并没有初始化长度

    private int size;//存储元素的个数

    public ArrayList(){
        //没有初始化长度，则默认为4
        this(4);
    }

    /**
     * 指定初始化长度
     * @param initSize
     */
    public ArrayList(int initSize) {
        elementData = new Object[initSize];
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        if(i < 0 || i >= size){
            throw new RuntimeException("数组索引越界异常：" + i);
        }
        return elementData[i];
    }

    @Override
    public boolean isEmpty() {
        return size == 0? true:false;
    }

    @Override
    public boolean contains(Object e) {
        return false;
    }

    @Override
    public int indexOf(Object e) {
        return 0;
    }

    @Override
    public void add(int i, Object e) {
        if(i < 0 || i >= size){
            throw new RuntimeException("数组索引越界异常：" + i);
        }
        //扩容，扩容一倍
        if(size == elementData.length){
            elementData = Arrays.copyOf(elementData,elementData.length * 2);
        }
        //移动元素
        for(int j = size ; j > i ; j--){
            elementData[j] = elementData[j-1];
        }
        elementData[i] = e;
    }

    @Override
    public void add(Object e) {
        //扩容，扩容一倍
        if(size == elementData.length){
           /* Object[] append = new Object[elementData.length * 2];
            for (int i = 0; i < elementData.length; i++) {
                append[i] = elementData[i];
            }
            elementData = append;*/
            elementData = Arrays.copyOf(elementData,elementData.length * 2);
        }
        elementData[size++] = e;
    }

    @Override
    public void addBefore(Object e, Object e1) {
    }

    @Override
    public void addAfter(Object e, Object e1) {

    }
}
```



​																								**链表：单链表的实现**

![image-20220904153233986](D:\学习\数据结构\image-20220904153233986.png)

![image-20220904153455898](D:\学习\数据结构\image-20220904153455898.png)

![image-20220904153803154](D:\学习\数据结构\image-20220904153803154.png)

```java
package com.wzs.datastructure.linetable;

public class Node {
    Object data;
    Node next;

    public Node() {
    }

    public Node(Object data) {
        this.data = data;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }
}

```

```java
package com.wzs.datastructure.linetable;

public class SingleLinkedList implements List{

    private Node head = new Node();//头节点

    private int size;

    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        Node p = head;
        for(int j = 0 ; j <= i ; j++){
            p = p.next;
        }
        return p.data;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean contains(Object e) {
        return false;
    }

    @Override
    public int indexOf(Object e) {
        return 0;
    }

    @Override
    public void add(int i, Object e) {
        Node p = head;
        for(int j = 0 ; j < i ; j++){
            p = p.next;
        }
        Node node = new Node(e);
        //指明后继节点
        node.next= p.next;
        //指明前驱节点
        p.next = node;
        size++;
    }

    @Override
    public void add(Object e) {
        Node node = new Node(e);
        Node p = head;
        //找到最后一个节点
        for(int i = 0 ; i < size ; i++){
           p = p.next;
        }
        p.next = node;
        size++;
    }

    @Override
    public void addBefore(Object e, Object e1) {

    }

    @Override
    public void addAfter(Object e, Object e1) {

    }
}

```

![image-20220904163738104](D:\学习\数据结构\image-20220904163738104.png)

![image-20220904163814358](D:\学习\数据结构\image-20220904163814358.png)

![image-20220904163839226](D:\学习\数据结构\image-20220904163839226.png)



![image-20220904164029694](D:\学习\数据结构\image-20220904164029694.png)

## 五、栈和队列

![image-20220904171513353](D:\学习\数据结构\image-20220904171513353.png)



![image-20220904204153975](D:\学习\数据结构\image-20220904204153975.png)

![image-20220904204259985](D:\学习\数据结构\image-20220904204259985.png)

![image-20220904205048699](D:\学习\数据结构\image-20220904205048699.png)

![image-20220904205109866](D:\学习\数据结构\image-20220904205109866.png)

![image-20220904204449595](D:\学习\数据结构\image-20220904204449595.png)

![image-20220904205410178](D:\学习\数据结构\image-20220904205410178.png)

![image-20220904205537195](D:\学习\数据结构\image-20220904205537195.png)

![image-20220904205700905](D:\学习\数据结构\image-20220904205700905.png)

![image-20220904211325698](D:\学习\数据结构\image-20220904211325698.png)

```java
package com.wzs.datastructure.stackqueue;

import java.util.Deque;
import java.util.LinkedList;

public class TestConversion {
    /**
     * 十进制转为二进制
     * @param args
     */
    public static void main(String[] args) {
        int num = 13;
        Deque stack = new LinkedList();
        do{
            //除以2取余数
            int mod = num % 2;
            stack.push(mod);
            //除以2得到商
            num = num / 2 ;
        }while (num > 0);//商大于0继续循环
        while (!stack.isEmpty()){
            System.out.print(stack.pop());
        }
    }
}
```

## 六、树和二叉树

### 1）树的基本概念

![image-20220904211559592](D:\学习\数据结构\image-20220904211559592.png)

![image-20220904211737182](D:\学习\数据结构\image-20220904211737182.png)

![image-20220904211936118](D:\学习\数据结构\image-20220904211936118.png)

![image-20220904212216009](D:\学习\数据结构\image-20220904212216009.png)

![image-20220904212301098](D:\学习\数据结构\image-20220904212301098.png)

### 2）二叉树

![image-20220904212600988](D:\学习\数据结构\image-20220904212600988.png)

![image-20220904212846193](D:\学习\数据结构\image-20220904212846193.png)

![image-20220904213129282](D:\学习\数据结构\image-20220904213129282.png)

![image-20220904213253399](D:\学习\数据结构\image-20220904213253399.png)

![image-20220904214226152](D:\学习\数据结构\image-20220904214226152.png)

![image-20220904214244701](D:\学习\数据结构\image-20220904214244701.png)

![image-20220904214432884](D:\学习\数据结构\image-20220904214432884.png)

![image-20220904214450422](D:\学习\数据结构\image-20220904214450422.png)

### 3）二叉树的实现

#### 1.二叉树遍历策略

![image-20220904214847181](D:\学习\数据结构\image-20220904214847181.png)

![image-20220904214935239](D:\学习\数据结构\image-20220904214935239.png)

2.二叉树节点

![image-20220904220941470](D:\学习\数据结构\image-20220904220941470.png)

```html
求1+2+3+...+n的和？
f(5) = f(4) + 5;
f(4) = f(3) + 4;
f(3) = f(2) + 3;
f(2) = f(1) + 2;
f(1) = 1;
```

![img](D:\学习\数据结构\a24b43d01ed87affe4ede5f8f56daddf.png)

## 七、图

### 1）图的定义

![image-20220905212419691](D:\学习\数据结构\image-20220905212419691.png)

![image-20220905212446055](D:\学习\数据结构\image-20220905212446055.png)

### 2）图的存储

![image-20220905212532375](D:\学习\数据结构\image-20220905212532375.png)

![image-20220905213106757](D:\学习\数据结构\image-20220905213106757.png)

### 3）图的遍历

![image-20220905213301515](D:\学习\数据结构\image-20220905213301515.png)